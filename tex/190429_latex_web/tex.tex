%TEMPLATE-BEGIN 1
\documentclass[uplatex,dvipdfmx]{jsarticle} \usepackage{amsmath,amssymb,bm}
\usepackage{verbatim} \usepackage{svg} \usepackage{graphicx}
\usepackage[dvipdfmx]{hyperref} \usepackage{pxjahyper}
\usepackage{paracol} \usepackage{threeparttable}
\usepackage{seqsplit}
%TEMPLATE-END
\title{\LaTeX をベースとしたウェブサイトについての検討} \author{} \date{2019-04-28 Sun}
\begin{document}
\maketitle


\section*{動機}
\LaTeX をベースとしたウェブサイトについて検討したい。

つまり、イメージとしては、あるURLにアクセスするといくつかの.pdfファイルへのリンクが並んでいて、あるリンクをクリックすると、その.pdfファイルが閲覧できる。要するに単に、{\bf .pdfファイルがあるウェブサイト}である。

また、そのそれぞれの.pdfファイルを作成する上では、{\bf \LaTeX を活用したい}のである。つまり、テキストエディタなどで.texファイルを編集し、何らかの\LaTeX 処理系を用いてそれを.pdfファイルにコンパイルし、オンラインのサーバ上にその.pdfファイルを配置し、.htmlファイルにおいてその.pdfファイルへのリンクを記載すればよい。

よいのだが、.texファイルを少し編集するたびに手作業でそれを行うのはあまり現実的ではないので、うまい{\bf 自動化が考えられないだろうか}、という論点をこの文書で考える。



\section*{そこまでして\LaTeX を使うか}
という問題がそもそもある。たいていの問題について、{\bf Markdown + MathJaxあたり}が美しい解決なのではないか。(.texファイルを用いた) \LaTeX が有用な場合があるとしても、それを過度に広げることは悪いデザインなのではないか。時流に逆行しているのではないか。

そしてそもそも、個人的には、MarkdownやMathJaxにすらほとんど用はなく、{\bf plain textでたいていは足りている}。plain textは、メタなコマンドがないので、なんでもコピペできて便利だ。思考のツールとして効率的だ。plain textへの信仰を捨てて\LaTeX を信仰する合理性はあるのか。

ただ、私が思うのは、悲しいかな、{\bf 数学と学術論文}が世界の頂点だということである。そしてそこでは英語が標準語だということである。そして、いわゆる「サピア＝ウォーフの仮説」もまた、残念だが事実だ。数式の記法を用いずして、数学的に考えることはできない。私自身は、数学や学術論文の世界にまで踏み込みたいというまでの欲はない。しかし、世俗的な安寧のない者が、知的向上の道まで閉ざされてしまえば、そこに一種の死を感じるというまでである。私は、考えるという営みを生活の一部として行っていきたい。そして、思考は記法に制約されるが、思考のツールとしての記法として、\LaTeX が当面において王だと考えられるのである。

私にとっての\LaTeX の優位性は、{\bf 単層のレイヤーとしてのその完結性}にある。それ以下でないことと同じだけ、それ以上でないことが重要である。例えば、HTMLは素晴らしい言語であり、汎用性がある。CSSやJavaScript、あるいはサーバサイドのPHPなどとも連関して、動的でインタラクティブに情報を表現することができる。しかしそれは、用途によっては行きすぎていないか。.pdfファイルならば、それを移動するときに、他のファイルへの依存性を考える必要がないし、ウィンドウサイズが変わった際の表現の変化を考える必要もない。ユーザからの入力を取らない、定数関数だ。

例えば、すでに触れた、Markdown + MathJaxは強力だろう。あるいは、Jupyter Notebookというものが、多くの用途で人気がある。しかし一つの不安は、それが数百年後も同様に人気か、という点にある。MarkdownからHTMLへのコンパイラの仕様は変化しないか、MathJaxによる数式の表示のあり方は変化しないか。一方で、\LaTeX は、要素技術の複合体というよりは、一つのまとまりである。よく見れば要素技術の複合体だが、{\bf 枯れた部分が多く}、その変化が遅い。

賢い人々は様々なツールをその時々の必要性によって使いこなすのだろうが、私は、考える必要のあることを{\bf 最小限に単純化}したい。\LaTeX を重視するなら、なんでもかんでも\LaTeX で済ませられないか、を考えるのだ。言語の壁の問題などもあり、\LaTeX を用いることがどの程度、時代の変化に強いか、大いに不安はあるが、使ってみたいと思うのである。

もとより、\LaTeX は{\bf 印刷のため}に強力だろう。というより、HTML が不思議と印刷に弱いというべきかもしれない。ウェブブラウザによって結果は大きく異なり、特に、A4ならA4でその出力結果をソースファイルから完全にコントロールするようなことは、全くできまい。個人的にさほど印刷が必要かというと、そうでもないのだが、用紙のサイズや文字の大きさが固定されてこそ、細かいレイアウトを考える意味がある、という面はある。

プログラミングのアルゴリズムを考えるにあたっても、コードそのものには結局は表現力がない。仕様全てをコードそのものに表現するというのは一般的に一つの夢だろうと思うが、不可能だろう。人間用のドキュメンテーションと実装との乖離は、将来に渡ってコストになるはずだ。人間用の記法において仕様定義を熟慮してから、やや可読性を軽視した実装をすることが、常に最も強力だろうと考えられる。結局常に、人間の思考活動においては、純粋に{\bf 人間用の記法が中心となる}のだ。その一つの理由は、一つの具体について複数の抽象が有用でありうることにあるかもしれない。



\section*{GitHubを用いるべきか}
GitHubを用いてはどうだろうか、と思った。オフラインなローカルとオンラインなリモートを同期させる方法としては、奇妙な依存性がなく、とても筋がいい。

しかし一つ思い浮かぶ問題は、Gitはテキストデータのためのものであって、.pdfは基本的にバイナリだろうということである。よって、.texに微細な変更があった場合の.pdfの更新について、効率的に差分を表示することはできず、素朴にgitを用いたならば、望まないデータ容量の消費が起こるのではないか。

それについては、何らかの力づくな方法で、Gitに格納されている過去のデータを破壊して削除していけばよいのではないか。それが可能かは未調査である。おそらくできるのではないか。しかし、GitやGitHubをこのように使うことは基本的に、とても筋が悪い。

そうして、GitリポジトリのdocsディレクトリをGitHub Pagesという機能でウェブサイトとして公開すれば、目的を果たせるのではないか。

なお、.texファイルが更新された際には、プログラムによって.pdfファイルとのバージョンの違いを検出し、.texファイルをコンパイルして、.pdfファイルを適切に配置する。そのようなプログラムの開発を検討しようというのが、この文書の趣旨である。実装には、Python 3言語を使うつもりだ。

なお、GitHubのリポジトリの容量は1 GBであり、1ファイルの容量は50 MB未満であるべきであるらしい。



\section*{ディレクトリ構成}
Gitリポジトリのルートに、docsディレクトリとtexディレクトリを置く。docsディレクトリはウェブサイトとして公開するためのディレクトリである。texディレクトリは、.texファイルらを配置するためのディレクトリである。

.texファイルは、コンパイルの際に中間ファイルを生成するなどすることが多い。よって、1つの.texファイルにはそれ専用のディレクトリを与えることが実用的だろう。よって、1つの.texファイルが1つのディレクトリに入っていることを前提に考える。.texファイルのファイル名は原則としてtex.texとするが、任意であっていい。しかし、ウェブサイトに配置される.pdfファイルについては、.texファイルを含むディレクトリの名称に、拡張子.pdfをつけたものとする。それが実用上便利だろうと思うからである。

.texファイルのあるディレクトリに、実用上、出力されるであろう.pdfファイルおよび中間生成物は、.gitignoreを利用して可能な限り無視することを原則とする。

直下に1つ以上の.texファイルを含むディレクトリを、「leafディレクトリ」と呼ぶことにする。leafディレクトリではないディレクトリを「branchディレクトリ」と呼ぶことにする。graph theoryにおけるleaf nodeとbranch nodeという呼称を援用してのことである。texディレクトリにおいて、leafディレクトリは、branchディレクトリによって階層的に配置されていていい。branchディレクトリの階層構造は、docsディレクトリの内部において反映される。

中心的な役割を果たすプログラムを、compile\_to\_website.pyと呼ぶことにする。compile\_to\_website.pyは、texディレクトリの直下に配置される。compile\_to\_website.pyの実行と実行時を、単に実行や実行時と呼ぶことにする。



\section*{実行時の処理}
実行されると、プログラムはまず、texディレクトリを再帰的に走査する。そして、leafディレクトリらのパスを得る。

次に、docsディレクトリを走査する。これにより、docsディレクトリの現状を知る。

compile\_to\_website.pyは、同じディレクトリにあるlog.txtファイルを(もしあれば)参照する。log.txtファイルは、.texの更新差分を考えるための資料である。

もしもlog.txtファイルが存在しなければ、docsディレクトリの中のファイルを全て削除して、全ての.texファイルをコンパイルし、docsディレクトリの中をゼロから構築しなおす。

対応するleafディレクトリが存在しない.pdfファイルは削除する。

存在する.pdfファイルのソースファイルである.texファイルのハッシュが、log.txtに記載されているはずである。記載されており、なおかつハッシュが変わっていないときのみ、当該.pdfファイルを、「更新不要(uptodate)」と判断する。更新不要であるleafディレクトリ以外について更新(update)する。


updateするとは、.texファイルをコンパイルし、.pdfファイルをdocsディレクトリの下位に配置することである。(とりあえずの仕様として、) leafディレクトリ内にすでに.pdfファイルが存在するときにも改めてコンパイルする。

更新処理が終わったならば、現在のtexディレクトリとdocsディレクトリの状況から、log.txtファイルの内容をゼロから作り直す。(同じファイルのハッシュを2回計算することによる計算量の増加は、許容していいと見込んでいる。)　その内容は、.pdfのパスから.texのハッシュへの連想配列である。

log.txtファイルの更新処理が終わったならば、.htmlファイルらを作成する。



\section*{Gitデータの初期化について}
上で触れたように、.pdfファイルはバイナリファイルであるから、Gitに適さない。頻繁に更新すると無駄に容量が増加すると思われる。これを避けるためには、.pdfについて、最新のデータ以外は削除したい。

しかしながら、それを行うごく簡単な方法は見当たらなかった。しかし、Gitリポジトリ全体を初期化してしまう方法は、シンプルで確実そうなものが紹介されていた。よって、Gitリポジトリ全体を初期化する方法で、下のPythonコードとして実装した。

この方法の短所の一つとして、Gitによって本来は差分が記録されてよいはずの.texファイルなど、一切のファイルについて、差分やバックアップのようなものは一切得られないということである。データを喪失するリスクがあるだろう。



\section*{参照されているファイルについて}
.texファイルの更新のみチェックするという考えでいたが、\textbackslash verbatiminputなどとして参照しているファイルが更新されていても無視してしまうのは問題な気がしてきた。未解決。input対象は必ずinputディレクトリ以下にあるという前提にして、処理すればよいだろうか。



\section*{compile\_to\_website.py}
\verbatiminput{input/compile_to_website.py}


\section*{push\_after\_delete\_everything.py}
\verbatiminput{input/push_after_delete_everything.py}


\section*{modify\_preamble.py}
\verbatiminput{input/modify_preamble.py}



\vspace{\baselineskip}
\begin{paracol}{2}
\switchcolumn
\end{paracol}
\end{document}
